	/*
	var fbuffer1 = gl.createFramebuffer();
	var fbuffer2 = gl.createFramebuffer();
	//gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbuffer1);
	gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fbuffer2);
		
	gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, comp2.getTexture(), 0);
	gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, utexture, 0);
	gl.readBuffer(gl.COLOR_ATTACHMENT0);
	gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
	gl.blitFramebuffer(0, 0, renderW, renderH,
		renderW/2, renderH/2,renderW, renderH,
		gl.COLOR_BUFFER_BIT, gl.NEAREST);
	visualizeBuffer();
	*/


function mandelError(cx, cy, iterations, array) {
    var x = 0.0;
    var y = 0.0;
    var xerr = 0;
    var yerr = 0;
    var eps = 5.960464477539063e-08;
    function g(n) {
        return (n*eps)/(1 - n*eps)
    }
    function add_err(a, b, aerr, berr) {
        return aerr + berr + g(1)*(Math.abs(a + b) + aerr + berr);
    }
    function mul_err(a, b, aerr, berr) {
        return (Math.abs(b*aerr) + Math.abs(a*berr) + aerr*berr) + g(1)*Math.abs(a*b);
    }
    var nerrors = 0;
    for (var i = 0; i < iterations; i++) {
        var xx = x*x;
        var yy = y*y;
        if (xx + yy > 4) {
            return i;
        }
        
        var xxerr = mul_err(x, x, xerr, xerr);
        var yyerr = mul_err(y, y, yerr, yerr);
        var xyerr = mul_err(x, y, xerr, yerr);
        var xerr2 = add_err(xx, -yy, xxerr, yyerr);
        xerr2 = add_err(xx - yy, cx, xerr2, 0);
        var yerr2 = mul_err(x, y, xerr, yerr);
        yerr2 = add_err(2*x*y, cy, yerr2, 0);
        xerr = xerr2;
        yerr = yerr2;
        
        var x2 = xx - yy + cx;
        y = 2.0 * x * y + cy;
        x = x2;
        
        if (xerr*0 > 0.00001 || yerr > 0.00001) {
            nerrors++;
            xerr = 0;
        }
        console.log(xerr);
    }
    return nerrors;
}

tostring: function(x) {
        var a = x[0];
        var b = x[1];
        
        if (Math.abs(b) > Math.abs(a)) {
            var t = a;
            a = b;
            b = t;
        }
        
        var subtraction = ((a < 0) != (b < 0));
        var negative = (a < 0);
        
        //a = Math.abs(a).toFixed(20);
        //b = Math.abs(b).toFixed(20);
        a = toFixed1000(a);
        b = toFixed1000(b);
        
        if (a.includes('e') || b.includes('e') || a.length - a.indexOf('.') !=  21 || b.length - b.indexOf('.') != 21) {
            console.log('aaa', a, b);
            return b;
        }
        
        
        a = a.split('').reverse();
        b = b.split('').reverse();
        
        while (a.length != Math.max(a.length, b.length)) { a.push(0); }
        while (b.length != Math.max(a.length, b.length)) { b.push(0); }
        
        function add(a, b) {
            var carry = 0;
            for (var i = 0; i < a.length; i++) {
                if (a[i] != '.') {
                    var r = carry + parseInt(a[i]) + parseInt(b[i]);
                    if (r > 9) {
                        carry = 1;
                        r -= 10;
                    } else {
                        carry = 0;
                    }
                    a[i] = r.toString();
                } else {
                    if (i != 20 || b[i] != '.') {
                    //    alert('aaa'); // todo
                    }
                }
            }
            if (carry) {
                a.push('1');
            }
        }
        
        function sub(a, b) {
            var carry = 0;
            for (var i = 0; i < a.length; i++) {
                if (a[i] != '.') {
                    var r = parseInt(a[i]) - parseInt(b[i]) + carry;
                    if (r < 0) {
                        carry = -1;
                        r += 10;
                    } else {
                        carry = 0;
                    }
                    a[i] = r.toString();
                } else {
                    if (i != 20 || b[i] != '.') {
                        //alert('aaa'); // todo
                    }
                }
            }
            if (carry) {
                alert('aaa'); // todo
            }
        }
        
        if (subtraction) {
            sub(a, b);
        } else {
            add(a, b);
        }
        
        return ((negative) ? '-' : '') + a.reverse().join('');
    }

class Loader {
    constructor(gl) {
        this.gl = args.gl;
		
		this.eye = cloneEye(args.eye);
        
        this.renderTexture = M.gl_util.createRenderTexture(gl, 10, 10);
        
		this.fbuffer = args.frameBuffer;
		gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbuffer);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTexture, 0);
        
		this.program = M.game_gl.createProgram1();
        var orbiter = new M.mandel.OrbitComputer();
        orbiter.compute(0, 0, 1); // stub orbit
        this.orbitTexture = orbiter.getTexture(gl);
    }
    
    doSomeTesting(cb) {
    }
    
    load(iterations) {
        var gl = this.gl;
		gl.useProgram(this.program);
		
		gl.uniform1f(gl.getUniformLocation(this.program, "screenAspectRatio"), 1);
		gl.uniform1f(gl.getUniformLocation(this.program, "scale"), blackEye.scale);
		gl.uniform1f(gl.getUniformLocation(this.program, "one"), 1.0);
		M.gl_util.glUniformD(gl.getUniformLocation(this.program, "offsetX"), ns.number(blackEye.offsetX));
		M.gl_util.glUniformD(gl.getUniformLocation(this.program, "offsetY"), ns.number(blackEye.offsetY));
		gl.uniform1i(gl.getUniformLocation(this.program, "iterations"), iterations);
        gl.uniform1i(gl.getUniformLocation(this.program, "isPyramidLayer"), 0);

		gl.useProgram(c.program);
		gl.bindFramebuffer(gl.FRAMEBUFFER, c.fbuffer);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, c.renderTexture, 0);
        
        gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, this.orbitTexture);
		gl.uniform1i(gl.getUniformLocation(this.program, "refOrbit"), 0);
		gl.uniform1i(gl.getUniformLocation(this.program, "refOrbitLen"), 1);
        gl.uniform1f(gl.getUniformLocation(this.program, "refOrbitEyeOffsetX"), 0);
        gl.uniform1f(gl.getUniformLocation(this.program, "refOrbitEyeOffsetY"), 0);
		
		// todo bind something to textures
        gl.viewport(0, 0, 10, 10);
        gl.uniform4f(gl.getUniformLocation(c.program, "viewport"), -1, -1, 2, 2);
        var primitiveType = gl.TRIANGLES;
		var offset = 0;
		var count = 6;
		gl.drawArrays(primitiveType, offset, count);
    }
    
    _debug_overload() {
        this.eye.iterations = 0xFFFFDEAD;
        this.computer.reset(this.eye);
        var now = performance.now();
        canvas.addEventListener("webglcontextlost", function(event) {
            var dt = performance.now() - now;
            console.log('lost context after ms', dt);
        }, false);
        this.computer.computeAll();
    }
    
    getIterationsPerMs() {
    }
};

c.computeSome = function(timeLimit, callback) {
	// todo handle lost context
	var iterationsPerCall = 10000000000;
	var calls = 0;
	var callsAhead = Math.min(100, Math.max(1, iterationsPerCall / 100 / 100 / eye.iterations));
	var waitPeriod = 5;
	var timeUsed = 0;
	var sync;
	var startTime = performance.now();
	
	function blast() {
		console.log(performance.now(), 'blast');
		//callsTime = performance.now();
		sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
		for (var i = 0; i < callsAhead && !job.done; i++) {
			job.iteration();
			calls++;
		}
	
		setTimeout(timerCb, waitPeriod);
	}
	
	function timerCb() {
		var status = gl.getSyncParameter(sync, gl.SYNC_STATUS);
		if (status != gl.SIGNALED) {
			console.log(performance.now(), 'zzz');
			setTimeout(timerCb, waitPeriod);
		} else {
			gl.deleteSync(sync);
			var now = performance.now();
			if (job.done) {
				console.log(performance.now(), 'done', performance.now() - startTime);
				callback(true, now);
				return;
			}
			
			// maybe we have enough time left to make more calls
			var blastTime = callsAhead * (now - startTime) / calls;
			if (now + blastTime < timeLimit) {
				blast();
				return
			} else {
				console.log(performance.now(), 'uvi');
				callback(false, now);
			}
		}
	}
	
	blast();
}

return c;
}


	
	take(eye, txt) {
		this.eye = cloneEye(eye);
		console.log('take', this.eye);
		var gl = this.gl;
		gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.fbuffer1);
		gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fbuffer2);
			
		gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, comp2.getTexture(), 0);
		gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
		gl.readBuffer(gl.COLOR_ATTACHMENT0);
		gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
		gl.blitFramebuffer(
			0, 0, this.w, this.h,
			0, 0, this.w, this.h,
			gl.COLOR_BUFFER_BIT, gl.NEAREST
		);
	}

	combine2(eye, texture, w, h) {
		// convert coordinate of a pixel in one view to another (either x or y)
		// e1, e2 - eye offsets of the views
		// hside1, hside2 - half of the side of the views in
		//                  real space (width or height correspondingly)
		// ps1, ps2 - the width of one pixel in real space in the views
		// x2 - the pixel coordinate in the view2
		// returns the pixel coordinate in the view1
		function convertPixelCoord(e1, e2, hside1, hside2, ps1, ps2, x2) {
			// :: 1) 0.5ps + ps*x + e - (hside/S)*S = e + t*s
			// ::    t*s = ps*(0.5+x) - hside
			// :: 2) e1 + s1*t1 = e2 + s2*t2
			// ::    e1 + ps1*(0.5+x1) - hside1 = e2 + ps2*(0.5+x2) - hside2
			var tmp = e2 - e1 + hside1 - hside2 + ps2*(0.5 + x2);
			var x1 = tmp/ps1 - 0.5;
			return Math.floor(x1);
		}
		
		var gl = this.gl;
		gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.fbuffer1);
		gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fbuffer2);
			
		gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, comp2.getTexture(), 0);
		gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
		gl.readBuffer(gl.COLOR_ATTACHMENT0);
		gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
		var hside1 = this.eye.scale * (this.w/this.h);
		
		var ps1 = 2*hside1/this.w;
		var ps2 = 2*hside2/w;
		var ratio1 = this.w/this.h;
		var ratio2 = w/h;
		var hw1 = this.eye.scale*ratio1;
		var hw2 = eye.scale*ratio2;
		gl.blitFramebuffer(
			0, 0, this.w, this.h,
			convertPixelCoord(this.eye.offsetX, eye.offsetX, hw1, hw2, ps1, ps2, 0), 
			convertPixelCoord(this.eye.offsetY, eye.offsetY, this.eye.scale, eye.scale, ps1, ps2, 0), 
			convertPixelCoord(this.eye.offsetX, eye.offsetX, hw1, hw2, eye.scale*ratio2, ps1, ps2, w),
			convertPixelCoord(this.eye.offsetY, eye.offsetY, this.eye.scale, eye.scale, ps1, ps2, h),
			gl.COLOR_BUFFER_BIT, gl.NEAREST
		);
	}


function glUpdateRefOrbit2(array, orbitLen) {	
	gl.activeTexture(gl.TEXTURE0);
	gl.uniform1i(gl.getUniformLocation(program, "refOrbit"), 0);
	gl.bindTexture(gl.TEXTURE_2D, refOrbitTexture);
	var t0 = performance.now();
	gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 1024, 512, gl.RG, gl.FLOAT, array);
	var dt = performance.now() - t0;
	gl.uniform1i(gl.getUniformLocation(program, "refOrbitLen"), orbitLen);
	//console.log("perf", orbitLen, dt);
}
c.drawDirect = function() {
	gl.clearColor(1, 0, 1, 1);
	gl.clear(gl.COLOR_BUFFER_BIT);
	gl.useProgram(program);
	
	if (false) {
		var orbitLen = mandelOrbit(Game.vars.offsetX, Game.vars.offsetY, Game.vars.iterations, orbitArray);
		//var orbit = testOrbit();
		glUpdateRefOrbit(orbitArray, orbitLen);
	}

	gl.uniform4f(gl.getUniformLocation(program, "viewport"), -bufParam.ratio, -1, 2*bufParam.ratio, 2);
	var primitiveType = gl.TRIANGLES;
	var offset = 0;
	var count = 6;
	gl.drawArrays(primitiveType, offset, count);
		c.done = true;
}

function myclick() {
	saveLabels();
	//Game.resizeCanvas();
	const ext = gl.getExtension('EXT_disjoint_timer_query_webgl2');
	const query = gl.createQuery();
	gl.beginQuery(ext.TIME_ELAPSED_EXT, query);
	var t0 = performance.now();
	
	//Game.draw();
	
	gl.endQuery(ext.TIME_ELAPSED_EXT);
	var i = 0;
	function checkFlag() {
		const available = gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE);
		if (available) {
			const dt = gl.getQueryParameter(query, gl.QUERY_RESULT);		
			var str = 'dt1: ' + dt/1e6;
			document.getElementById("infolabel").innerText = str;
			return;
		} else {
			i++;
			if (i >= 100) {
				document.getElementById("infolabel").innerText = 'too long!';
				return;
			}
			window.setTimeout(checkFlag, 100);
		}
	}
	checkFlag();
}

//useful places



var f32eye = {
    scale: 0.000013051581850936334, //f32 star
    //scale: 0.000013051581850936334/16,
    offsetX: ns.init(-1.6331274114303949), //32 star
    //offsetX: -1.6331328461523655,
    offsetY: ns.init(0),
    iterations: 100,
};

var mystEye = {
    offsetX: -1.6331463553828895,
    offsetY: 5.843362841437326e-7,
    scale: 1/117916235.51574515,
    iterations: 100,
};

var immovableEye = {
    offsetX: ns.init(-1.6331395811715201),
    offsetY: ns.init(0),
    scale: 1/173413815746731,
    iterations: 1000,
};

var ddLimitEye = {
    offsetX: ns.init(-1.6331395811715201),
    offsetY: ns.init(0),
    scale: 1/1.361052241705286e+30,
    iterations: 1000,
};

var almostBlackEye = {
    scale: 1/3.7974983358324126,
    offsetX: ns.init(-0.224190897277197292991601784706),
    offsetY: ns.init(0),
    iterations: 100,
};

// the derivative's magnitude is so big it messes up calculations
var error1 = {
    scale: 1/371727914934102.25,
    offsetX: ns.init(-0.710631357018485121379569591227),
    offsetY: ns.init(0.289388796050924990144181947471),
    iterations: 1000,
};

var error2 = {
    scale: 1/492565378.95253223,
    offsetX: ns.init(-0.672719884767477349640785178053),
    offsetY: ns.init(0.445552821138786914190177412820),
    iterations: 8000,
};

// here ff_main glitches strongly
var deep1 = {
    scale: 1/1342940438193.1177,
    offsetX: ns.init(-0.672719885909637826948426209128),
    offsetY: ns.init(0.445552820999778387278666968996),
    iterations: 64000,
}

// here the magnitude of the derivative caused the distance estimator to glitch
var deep2 = {
    scale: 1/61965827360231.16,
    offsetX: ns.init(-0.774680610627246024613157260319),
    offsetY: ns.init(0.137416885603266397675170651382),
    iterations: 4000,
}


// interesting places
var error2 = {
	scale: 1/6818231566116016000,
	offsetX: ns.init(-0.710631357018489340227063166822),
	offsetY: ns.init(0.289388796050926433434113960175),
	previewScale: 1,
	iterations: 1000,
};

var vitki = {
	scale: 4.89889e-28,
	offsetX: ns.init(-0.7538048869715159914508542590472882274151),
	offsetY: ns.init(-0.0473165168068373370968674669554347697321),
	previewScale: 1,
	iterations: 80000,

}

var macaroni1 = {	
    scale: 1/5077091.561327687,
	offsetX: ns.init(-0.001311564150764691618830659614),
	offsetY: ns.init(0.757143982512533675333088467596),
	previewScale: 1,
	iterations: 8000,
}

var vitki1 = {
    scale: 1/1336956.8890712315,
	offsetX: ns.init(-1.623478581296714073900488983782),
	offsetY: ns.init(-0.000341081451639758709455663155),
	previewScale: 1,
	iterations: 1000,
}

var cscope = {
0.2812736633680872270509045000241887273623
0.0119906872191721991661175769073460179273
1.67328e-16
120000
}

whirlpool = {
-0.7746808122540398955339655499073344553088
0.1374168077120316540547160124951082066013
2.24777e-17
4000
}