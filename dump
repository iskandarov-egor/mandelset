class Loader {
    constructor(gl) {
        this.gl = args.gl;
		
		this.eye = cloneEye(args.eye);
        
        this.renderTexture = M.gl_util.createRenderTexture(gl, 10, 10);
        
		this.fbuffer = args.frameBuffer;
		gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbuffer);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTexture, 0);
        
		this.program = M.game_gl.createProgram1();
        var orbiter = new M.mandel.OrbitComputer();
        orbiter.compute(0, 0, 1); // stub orbit
        this.orbitTexture = orbiter.getTexture(gl);
    }
    
    doSomeTesting(cb) {
    }
    
    load(iterations) {
        var gl = this.gl;
		gl.useProgram(this.program);
		
		gl.uniform1f(gl.getUniformLocation(this.program, "screenAspectRatio"), 1);
		gl.uniform1f(gl.getUniformLocation(this.program, "scale"), blackEye.scale);
		gl.uniform1f(gl.getUniformLocation(this.program, "one"), 1.0);
		M.gl_util.glUniformD(gl.getUniformLocation(this.program, "offsetX"), ns.number(blackEye.offsetX));
		M.gl_util.glUniformD(gl.getUniformLocation(this.program, "offsetY"), ns.number(blackEye.offsetY));
		gl.uniform1i(gl.getUniformLocation(this.program, "iterations"), iterations);
        gl.uniform1i(gl.getUniformLocation(this.program, "isPyramidLayer"), 0);

		gl.useProgram(c.program);
		gl.bindFramebuffer(gl.FRAMEBUFFER, c.fbuffer);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, c.renderTexture, 0);
        
        gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, this.orbitTexture);
		gl.uniform1i(gl.getUniformLocation(this.program, "refOrbit"), 0);
		gl.uniform1i(gl.getUniformLocation(this.program, "refOrbitLen"), 1);
        gl.uniform1f(gl.getUniformLocation(this.program, "refOrbitEyeOffsetX"), 0);
        gl.uniform1f(gl.getUniformLocation(this.program, "refOrbitEyeOffsetY"), 0);
		
		// todo bind something to textures
        gl.viewport(0, 0, 10, 10);
        gl.uniform4f(gl.getUniformLocation(c.program, "viewport"), -1, -1, 2, 2);
        var primitiveType = gl.TRIANGLES;
		var offset = 0;
		var count = 6;
		gl.drawArrays(primitiveType, offset, count);
    }
    
    _debug_overload() {
        this.eye.iterations = 0xFFFFDEAD;
        this.computer.reset(this.eye);
        var now = performance.now();
        canvas.addEventListener("webglcontextlost", function(event) {
            var dt = performance.now() - now;
            console.log('lost context after ms', dt);
        }, false);
        this.computer.computeAll();
    }
    
    getIterationsPerMs() {
    }
};

c.computeSome = function(timeLimit, callback) {
	// todo handle lost context
	var iterationsPerCall = 10000000000;
	var calls = 0;
	var callsAhead = Math.min(100, Math.max(1, iterationsPerCall / 100 / 100 / eye.iterations));
	var waitPeriod = 5;
	var timeUsed = 0;
	var sync;
	var startTime = performance.now();
	
	function blast() {
		console.log(performance.now(), 'blast');
		//callsTime = performance.now();
		sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
		for (var i = 0; i < callsAhead && !job.done; i++) {
			job.iteration();
			calls++;
		}
	
		setTimeout(timerCb, waitPeriod);
	}
	
	function timerCb() {
		var status = gl.getSyncParameter(sync, gl.SYNC_STATUS);
		if (status != gl.SIGNALED) {
			console.log(performance.now(), 'zzz');
			setTimeout(timerCb, waitPeriod);
		} else {
			gl.deleteSync(sync);
			var now = performance.now();
			if (job.done) {
				console.log(performance.now(), 'done', performance.now() - startTime);
				callback(true, now);
				return;
			}
			
			// maybe we have enough time left to make more calls
			var blastTime = callsAhead * (now - startTime) / calls;
			if (now + blastTime < timeLimit) {
				blast();
				return
			} else {
				console.log(performance.now(), 'uvi');
				callback(false, now);
			}
		}
	}
	
	blast();
}

return c;
}


	
	take(eye, txt) {
		this.eye = cloneEye(eye);
		console.log('take', this.eye);
		var gl = this.gl;
		gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.fbuffer1);
		gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fbuffer2);
			
		gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, comp2.getTexture(), 0);
		gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
		gl.readBuffer(gl.COLOR_ATTACHMENT0);
		gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
		gl.blitFramebuffer(
			0, 0, this.w, this.h,
			0, 0, this.w, this.h,
			gl.COLOR_BUFFER_BIT, gl.NEAREST
		);
	}

	combine2(eye, texture, w, h) {
		// convert coordinate of a pixel in one view to another (either x or y)
		// e1, e2 - eye offsets of the views
		// hside1, hside2 - half of the side of the views in
		//                  real space (width or height correspondingly)
		// ps1, ps2 - the width of one pixel in real space in the views
		// x2 - the pixel coordinate in the view2
		// returns the pixel coordinate in the view1
		function convertPixelCoord(e1, e2, hside1, hside2, ps1, ps2, x2) {
			// :: 1) 0.5ps + ps*x + e - (hside/S)*S = e + t*s
			// ::    t*s = ps*(0.5+x) - hside
			// :: 2) e1 + s1*t1 = e2 + s2*t2
			// ::    e1 + ps1*(0.5+x1) - hside1 = e2 + ps2*(0.5+x2) - hside2
			var tmp = e2 - e1 + hside1 - hside2 + ps2*(0.5 + x2);
			var x1 = tmp/ps1 - 0.5;
			return Math.floor(x1);
		}
		
		var gl = this.gl;
		gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.fbuffer1);
		gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fbuffer2);
			
		gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, comp2.getTexture(), 0);
		gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
		gl.readBuffer(gl.COLOR_ATTACHMENT0);
		gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
		var hside1 = this.eye.scale * (this.w/this.h);
		
		var ps1 = 2*hside1/this.w;
		var ps2 = 2*hside2/w;
		var ratio1 = this.w/this.h;
		var ratio2 = w/h;
		var hw1 = this.eye.scale*ratio1;
		var hw2 = eye.scale*ratio2;
		gl.blitFramebuffer(
			0, 0, this.w, this.h,
			convertPixelCoord(this.eye.offsetX, eye.offsetX, hw1, hw2, ps1, ps2, 0), 
			convertPixelCoord(this.eye.offsetY, eye.offsetY, this.eye.scale, eye.scale, ps1, ps2, 0), 
			convertPixelCoord(this.eye.offsetX, eye.offsetX, hw1, hw2, eye.scale*ratio2, ps1, ps2, w),
			convertPixelCoord(this.eye.offsetY, eye.offsetY, this.eye.scale, eye.scale, ps1, ps2, h),
			gl.COLOR_BUFFER_BIT, gl.NEAREST
		);
	}


function glUpdateRefOrbit2(array, orbitLen) {	
	gl.activeTexture(gl.TEXTURE0);
	gl.uniform1i(gl.getUniformLocation(program, "refOrbit"), 0);
	gl.bindTexture(gl.TEXTURE_2D, refOrbitTexture);
	var t0 = performance.now();
	gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 1024, 512, gl.RG, gl.FLOAT, array);
	var dt = performance.now() - t0;
	gl.uniform1i(gl.getUniformLocation(program, "refOrbitLen"), orbitLen);
	//console.log("perf", orbitLen, dt);
}
c.drawDirect = function() {
	gl.clearColor(1, 0, 1, 1);
	gl.clear(gl.COLOR_BUFFER_BIT);
	gl.useProgram(program);
	
	if (false) {
		var orbitLen = mandelOrbit(Game.vars.offsetX, Game.vars.offsetY, Game.vars.iterations, orbitArray);
		//var orbit = testOrbit();
		glUpdateRefOrbit(orbitArray, orbitLen);
	}

	gl.uniform4f(gl.getUniformLocation(program, "viewport"), -bufParam.ratio, -1, 2*bufParam.ratio, 2);
	var primitiveType = gl.TRIANGLES;
	var offset = 0;
	var count = 6;
	gl.drawArrays(primitiveType, offset, count);
		c.done = true;
}

function myclick() {
	saveLabels();
	//Game.resizeCanvas();
	const ext = gl.getExtension('EXT_disjoint_timer_query_webgl2');
	const query = gl.createQuery();
	gl.beginQuery(ext.TIME_ELAPSED_EXT, query);
	var t0 = performance.now();
	
	//Game.draw();
	
	gl.endQuery(ext.TIME_ELAPSED_EXT);
	var i = 0;
	function checkFlag() {
		const available = gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE);
		if (available) {
			const dt = gl.getQueryParameter(query, gl.QUERY_RESULT);		
			var str = 'dt1: ' + dt/1e6;
			document.getElementById("infolabel").innerText = str;
			return;
		} else {
			i++;
			if (i >= 100) {
				document.getElementById("infolabel").innerText = 'too long!';
				return;
			}
			window.setTimeout(checkFlag, 100);
		}
	}
	checkFlag();
}

Thanks gman. I think I'll use the time from this extension if it's available. I also have an onboard Intel GPU any my results are all above 10ms. Also they (and yours) look suspiciously close to multiples of 1/60 (16, 33, 50). Maybe it has to do with the browsers drawing rate.
